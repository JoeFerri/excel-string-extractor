ExcelStringExtractor

AVVIO Script:

se il nome del file inizia con "::" allora è considerato una espressione regolare
Es. ::\bfil-[a-z]{3,4}
    ::\./path/[a-z]?
	
il file output di default si chiama output.xlsx

-u | --unique : l'output conterrà soltanto stringhe univoche
-uf | --unique-file "<file_1>,...,<file_n>" l'output dei file elencati conterrà soltanto stringhe univoche
-us | --unique-sheet "<sheet_1>,...,<sheet_n>" l'output dei fogli elencati conterrà soltanto stringhe univoche
-uc | --unique-count : aggiunge la colonna "count" con il numero di occorrenze della stringa

viene passato il nome del file da mappare
viene passato il nome del file con la lista dei file da passare
  -l | --list <file_name> [<foglio_lista>]
se la lista è un .xlsx allora i nomi dei file sono nel primo foglio alla colonna A a partire dalla riga 1 o 2
se viene passato il parametro opzionale foglio_lista allora viene usato tale foglio per la lista
  -lc | --list-config <file_name> <foglio_lista> <foglio_configurazione>
    se viene usato -lc i 3 argomenti sono obbligatori
	<foglio_configurazione> + il foglio con la configurazione dell'elaborazione

-co | --config <file.json> : il file.json è utilizzato per la configurazione dell'elaborazione
                             usato al posto o insieme ai parametri da linea di comando

se c'è un conflitto nei file di configurazione prevale il comando più a destra della lista di parametri passati
(viene mostrato un Warning su terminale)

i nomi dei file vengono inseriti compresi di estensione (.xlsx, .csv, ...)
i nomi dei file vengono inseriti senza estensione:
  se il file non esiste, lo script prova aggiungendo le estensioni conosciute
-o | --out <file_output>
-eo | --ext-out <formato> : csv | xlsx | txt
  sovrascrive l'estensione del file output
-de | --delimiter <delim> : , | ; | ... delimitatore se il formato è csv

fileList = []
  fileList contiene 1 o n file da processare
  per ogni file in fileList esegue result = elabora_file(file)
  elabora_file() viene eseguito in parallelo da un processo p_n in Pool
  ogni p_n elabora i fogli del singolo file
    ogni foglio è elaborato da un thread in Pool
	
-mp | --multi-proc <num_proc> : usare num_proc numero processi in multiprocessing (default 1 processo)
-mt | --multi-thr <num_thr>   : usare num_thr numero thread in multithreading (default 1 thread)

resultAll = []
  resultAll.push(result)
  result = (nome_file,dfi,(t_1,t_2,...))
  dfi = {} opzioni... non usato per ora
  t_n = (nome_foglio,dfo,(l_1,l_2,...))
  dfo = {} opzioni... non usato per ora
  l_n = stringa della cella n
  
di default vengono catturate soltanto le stringhe con almeno un carattere alfabetico
-d | --digit  : le stringhe di soli numeri sono catturate (default no)
-w | --word   : solo le stringhe con una sola parola sono catturate (default anche stringhe con spazi)
-t | --text   : solo le stringhe con caratteri alfabetici e 0 o n spazi sono catturate
-s | --string : solo le stringhe con caratteri alfabetici (1 o n) e numeri (1 o m) con 0 o k spazi intermedi
-r | --raw    : tutte le stringhe sono catturate
-re | --regex <pattern> : vengono catturate solo le stringhe che corrispondono al pattern
-re sovrascrive le altre opzioni
(default -t -s)

-i | --include "file=x|sheet=x|seq=x(uential) 0,1,2,3|type=x" (default solo colonna stringhe)
l'argomento di -i va messo tra virgolette
x := nuovo nome della colonna
le opzioni sono separate da virgola
se il nuovo nome contiene spazi, il segno = o virgole deve essere racchiuso da apici singoli
se il nuovo nome contiene un apice singolo deve utilizzare l'escape \'
-i seq 0 : aggiunge la colonna numero sequenziale a livello di cella (non resetta mai)
-i seq 1 : aggiunge la colonna numero sequenziale a livello di file (resetta con ogni file)
-i seq 2 : aggiunge la colonna numero sequenziale a livello di foglio (resetta con ogni foglio)
-i seq 3 : aggiunge la colonna numero sequenziale a livello di file e foglio (resetta con ogni file e foglio)

-i type : valori := number (solo cifre)
                    word   (solo caratteri alfabetici senza spazi intermedi)
					text   (solo caratteri alfabetici con 1 o n spazi intermedi)
					string (solo caratteri alfabetici (1 o n) e numeri (1 o m) con 0 o k spazi intermedi)
                    date   (data)
                    raw
Esempio: -i "file,sheet=foglio,seq=pr 2,type"
         -i "file='col n.',sheet='1,2',seq=t?ss# 2"   la colonna seq si chiama adesso "t?ss#"
		 -i "file=arm\',sheet='arm\' 2'"              la colonna file si chiama adesso "arm'", sheet si chiama "arm' 2"
		 -i "file='1=1'                               la colonna file si chiama adesso "1=1"
		 
-rn | --rename "<colonna_1>=<new_name_1>,<colonna_2>=<new_name_2>,..." cambia il nome della colonna
la colonna delle stringhe trovate si chiama di default "value"
segue le stesse regole del parametro -i con la differenza che se viene usato -i,
solo le colonne incluse dal comando verranno inserite nell'output, mentre
usando -rn viene cambiato solo il nome delle colonne, a prescindere se queste siano o meno incluse nell'output

-c | --custom "<colonna_1>::<regex_1> <colonna_2>::<regex_2> ... <colonna_n>::<regex_n>"
        include ulteriori n colonne chiamate colonna_1, colonna_2, ... colonna_n nelle quali
		inserisce rispettivamente le stringhe che corrispondono alle espressioni regolari regex_m
		il nome delle colonne può essere formato da qualunque carattere ma non può contenere "::"
		"::" separa il nome della colonna dalla sua espressione regolare
		" " separa una coppia nome_colonna,regex dalle altre
		le colonne si aggiungono alle colonne di default o incluse con il parametro -i

-mf | --multi-file : vengono generati n file per n file elaborati (default generato un solo file complessivo)
                     i file output si chiamano di default nome_file_origine.output.xlsx
-mf | --multi-file "<nome_file_1>=<nuovo_nome_file_1>, <...>"
                     i nomi file devono essere privi di path
					 se nuovo_nome_file_n ha estensione, viene utilizzato quel formato di output,
					 altrimenti viene usato .xlsx di default o il formato output indicato dai comandi/configurazione
-mfc | --multi-file-column ["<col_1>,<col_2>,...,<col_n>"] : vengono generati n file per le n colonne (1 file 1 colonna)
                                                             se restano colonne vengono inserite nel file unico 
															 i file output si chiamano di default nome_colonna_sanificata.xlsx
-mfc | --multi-file-column ["<col_1>=<new_col_1>,<col_2>,...,<col_n>=<new_col_n>"]
                                                             se specificato, il nome del file di output
															 della colonna col_n è new_col_n
															 se new_col_n ha estensione viene usato quel formato di output
-ln | --label-name "<col_i>==<label_i>,<file_j>==<label_j>,..." : crea delle etichette che identificano i file,
                                                                i fogli, le colonne, richiamabili nei comandi da linea di comando
																per rendere più leggibile la stringa di comando da terminale

Esempio di config.json:
		
